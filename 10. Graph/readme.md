# Графи - 09.01.2026

## Задачи

### Задача 01

Да се създаде шаблон на клас, представящ граф с елементи от произволен тип,
който използва списъци на съседство за представянето. Да се имплементират следните методи:

- `addVertex` - добавя връх в графа;
- `addEdge` - добавя ребро между два върха в графа само ако двата върха са в графа;
- `vertices` - връща контейнер от всичките върхове в графа;
- `adjacent(<vertex_type>)` - връща контейнер от всички съседни върхове на даден връх.
  Два върха `u` и `v` ще наричаме съседни, ако `(u,v)` е ребро в графа;
- `hasVertex(<vertex_type>)` - проверява дали даден връх се съдържа в графа;
- `hasEdge(<vertex_type>, <vertex_type>)` - проверява дали съществува ребро между два върха в графа;
- `isDirected` - проверява дали графът е ориентиран.

*Забележка*: Погрижете се класът да може да представя и ориентиран, и неориентиран граф.

### Задача 02

Да се създаде клас `GraphUtil`, предоставящ набор от някои основни алгоритми върху графи,
които са изброени по-долу. Методите на класа да могат да работят с произволен тип на граф,
за който приемаме, че ще имаме дефиниран горния интерфейс.

Да се дефинират функции, които имплементират:

- намиране броя върхове, излизащи от даден връх;
- намиране броя върхове, влизащи в даден връх;
- обжохдане в дълбочина, което връща контейнер, представящ последователното обжохдане на върховете в графа;
- обжохдане в ширина, което връща контейнер, представящ последователното обжохдане на върховете в графа;
- намиране броя на свързаните компоненти в *неориентиран* граф;
- неконструктивно съществуване на път между два върха;
- дължина на най-кратък път в граф между два върха;
- намиране всички пътища между два върха в граф, като всички такива пътища биват събрани в някакъв контейнер;
- топологическо сортиране на *ориентиран ацикличен* граф;
- проверка дали в граф има цикъл;
- проверка дали граф е двуделен.
