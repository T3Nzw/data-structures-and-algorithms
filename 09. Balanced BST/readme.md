# Балансирано двоично дърво за търсене

Балансираните двоично наредени дървета са частен случай
на двоични наредени дървета, които са *самобалансиращи се* -
т.е. поддържа се допълнителен инвариант на дървото,
който следва да се възстанови след всяка промяна по дървото
(добавяне или премахване на елемент).

В AVL дърветата, които ще разгледаме тук, се използва т.нар.
баланс-фактор, който се пресмята по следния начин:

- `balance_factor(pos) = height(pos.left()) - height(pos.right())`,

където `pos` представя някаква позиция в дървото, а `pos.left()`
и `pos.right()` връщат позициите на левия и десния наследник, респективно
(забележете, че е напълно възможно `pos` да е невалидна позиция).

Тогава, използвайки горната дефиниция за баланс-фактор, ще казваме,
че едно двоично наредено дърво е балансирано, ако за **всяка**
позиция в дървото `pos` е изпълнено, че

```
abs(balance_factor(pos)) <= 1
```

Това свойство за баланс на AVL дърветата не позволява израждането
на дървото до списък и подобрява асимптотичната сложност на
основните операции при балансираните двоично наредени дървета
спрямо небалансираните такива.

Съществуват и други видове балансирани двоични наредени дървета,
напр. *B-дървета*, *B+-дървета* (това е тире, не - минус),
*червено-черни дървета* и други.

## Операции

Балансираните двоични дървета за търсене поддържат три основни операции,
напълно аналогично на двоичните наредени дървета:

- добавяне на елемент;
- премахване на елемент;
- търсене на елемент.

Освен това се поддържат операции за ротации в дървото:

- лява ротация;
- дясна ротация;
- ляво-дясна ротация;
- дясно-лява ротация,

които се използват за възвръщането на баланс в дървото след операция,
която би го променила.

Самият факт, че баланс-факторът не може да бъде по-голям от 1,
ни дава дърво, където възлите са сравнително равномерно разпределени
в лявото и дясното поддърво. Това значително подобрява асимптотичната сложност
на горните операции, като за всяка от тях най-лошата сложност по време е `O(log n)`,
за разлика от небалансираните двоични наредени дървета, където в най-лошия случай
трябва да обходим абсолютно всички възли в дървото (за `n` на брой възела получаваме
най-лоша сложност по време от `O(n)`).

## Задачи

### Задача 01

Да се създаде шаблон на клас `AVLTree`, който представя балансирано двоично
наредено дърво. Да се създадат методи, позволяващи да се извършват
основните операции в дървото, а именно - добавяне, премахване и търсене на елемент,
като след всяка операция очакваме инвариантът на AVL дърветата да е спазен.

Да се създаде абстракция за позиция в дървото, която да позволява обхождане
по произволен начин.

*Бонус*: Реализирайте горния клас по два начина - като наследявате от класа
за двоично наредено дърво и без да наследявате (т.е. пишете всичко сами).

### Задача 02

Да се напишат тестове за по-горната имплементация на дърво, използвайки `doctest`.
За част от тестовете може да използвате класа [BinaryTreeUtil](../07. Binary Tree/BinaryTreeUtil.hpp).

Тестовете да демонстрират правилната работа на основните операции на дървото
и спазването на инварианта след прилагането на някаква операция над дървото.
