# Полезни неща, които да се знаят предварително за курса по СДП

Това е някакъв опит за cheat sheet, който да послужи за припомняне на
някои от темите по УП и ООП, които ще са ни необходими за този курс:

## Указатели

Указателите са тип данни, които съдържат число (обикновено 64-битово
при 64-битови архитектури на процесора), представящо адрес в паметта.
Обикновено на тези места в паметта има записани някакви данни и
тези числа "сочат" към началото на тези данни.

```c++
int x = 10;
int *ptr = &x;
```

<pre style="font-family: monospace; line-height: 1.2;">
         ┌──────┐
 ptr ───►│ x=10 │
         └──────┘
</pre>

Указателите като тип данни винаги имат един и същи размер,
независимо от типа на данните, към които сочат.

В определени случаи можем да имаме двоен, троен и т.н. указател
и различни "части" от неговия тип да са маркирани като константни
(т.е. неизменяеми чрез самия указател или самият указател не може
бъде променян). Тогава използваме правилото за четене на типа
отдясно на ляво:

```c++
int const *const ptr;
```

Горният тип се чете: "константен указател към константа от тип int".
Важно е да се отбележи, че ако `const` се намира вдясно от последната
`*` (т.е. указател), то **не можем да променяме самата променлива `ptr`**,
т.е. `ptr = ptr2;` е нелегално. Ако `const` се намира вляво от някаква `*`
(т.е. указател), то съответните данни **не могат да се променят през този
указател**, т.е. `*ptr = 10;` е нелегално.

## Динамична памет

Използваме динамична памет основно в случаите, когато не знаем размера
на някакъв обект/структура от данни предварително и когато тази СД
би трябвало да се разширява или смалява по някакъв начин (т.е. искаме
да променяме динамично нейната структура).

В C++ динамична памет се заделя чрез операторите `new` и `delete`:

- заделяне на памет за единичен обект:

  ```c++
  intr *ptr1 = new int;
  int *ptr2 = new int(10);
  ```

  На всеки оператор `new T(...)` трябва да съответства точно един оператор `delete`:

  ```c++ 
  delete ptr1;
  delete ptr2;
  ```

- заделяне на памет за много обекти **последователно** в паметта:

  ```c++
  int *arr1 = new int[10];
  int *arr2 = new int[10]{1,2,3,4};
  ```

  На всеки оператор `new T[...]` трябва да съответства точно един оператор `delete[]`:

  ```c++
  delete[] arr1;
  delete[] arr2;
  ```

Ако динамично заделена памет не се освободи правилно (т.е. вече тази памет е необходима
и потенциално загубим референция към нея), се получава т.нар. *изтичане на памет* (memory leak).

## Рекурсия и бектрекинг

Рекурсията е процес на обръщението на някакъв обект към себе си. В частност,
рекурсивните функции са функции, които сами се обръщат към себе си (т.е. извикват се сами).

Всяка рекурсивна функция има 3 основни компоненти:

- база - това е случаят, в който рекурсивната функция спира да
  извиква себе си. Ако базов случай липсва, то функцията ще продължи
  да се извиква сама и ще доведе до препълване на програмния стек (stack overflow);

- аргументи на функцията, които променяме - за да "имаме напредък" в изчисленията,
  които извършва тази функция, е необходимо на всяка стъпка (т.е. всяко рекурсивно извикване)
  да променяме част от аргументите, които са критични за това, което искаме като резултат от функцията.
  Такива могат да бъдат например индекси на масиви, преместване на указател, промяна на някакъв акумулатор
  (напр. сума при опашково-рекурсивна дефиниция на сума на числа) и др.

- рекурсивно извикване на функцията - правим го с "новите" аргументи на функцията от предишната стъпка.
  Рекурсивните извиквания могат да имат отложени операции (напр. `return n * fact(n-1);`) или
  функцията да се извиква повече от един път (напр. `return fib(n-1) + fib(n-2);`).


Бектркингът (връщане назад) е процес, при който изпробваме множество начини за извършване
на някаква операция и ако някой от начините не доведе до някакъв резултат,
се "връщаме назад" и пробваме друг начин. Пример за функции, използващи бектрекинг,
са функциите, намиращи път в някакъв лабиринт (моделиран чрез матрица), търсене на
някакъв елемент в разклонена структура от данни (дървета или графи) и т.н.
Връщането назад се реализира чрез рекурсия.

## Структури и класове

Структурите и класовете са начин да обединим различни типове данни в едно цяло.
Единствената разлика между двете е, че по подразбиране достъпът до полетата и методите
на структурите е публичен (public), а при класовете - частен (private).

```c++
struct Person {
  std::string name;
  unsigned int age;
};  // не забравяйте да сложите точка-запетая тук ;)
```

Достъпът на полетата и методите може да бъде променян чрез маркиране на даден блок
с етикет за достъп: `public`, `protected`, `private`.

Големината на дадена структура/клас невинаги е сума от големините на всичките типове данни,
които съдържа. В определени ситуации (описано е по-подробно в хранилището по ООП)
се получава т.нар. подравняване на структурите/класовете, понеже е по-оптимално на ниво
процесор.

Друго нещо, което много ще правим в този курс, е да използваме структури за представянето
на възли и връзките между тях в свързаните представяния на различни структури от данни
(повечето от тях). Много често ще имаме производна на следната структура:

```c++
template<typename T>
struct Node {
  T data;
  Node *next;
};
```

От **изключително** значение е да **НЕ** използваме директно обект от тип `Node`
за полето `next`, тъй като тогава ще получим безкрайно зацикляне при определянето на
големината на обект от тип `Node`. Затова **винаги** ще използваме указател към
типа на възела (понеже той винаги е с фиксирана големина).

## Шаблони на структури и класове

В повечето от случаите, когато пишем структури от данни, ще искаме те да работят
не само за един тип, а за множество от различни типове. В такъв случай използваме
шаблони на структури/класове:

```c++
template<typename T>
class vector {...};
```

Някои ключови неща за шаблоните в C++ са следните:

- могат да се използват и в контекста на функции (шаблони на функции);
- шаблонните променливи могат да бъдат както имена на типове (`typename`), така и някакви конкретни стойности (`bool`, `T`);
- при създаване на обект на шаблон на клас **НЕ** се компилират абсолютно всички методи, инстанцирани с конкретния тип, който
  сме указали, а само тези, които се използват. Това е важно, тъй като може да имате бъг в някой от методите, който не сте тествали,
  и компилаторът **НЯМА** да ви даде информация за това, ако методът не е използван никъде. Затова пишете тестовете си внимателно. :)

*Лирическо отклонение по последната точка*: Ако идвате от някой друг език, в който контейнерите директно могат да се извеждат
на стандартния изход (напр. `print([1,2,3])` в Python), може би сте се чудили защо `std::vector` няма `print` метод или
overload за сериализацията на вектор в поток (`std::ostream &operator<<(std::ostream &os, std::vector<T> const &v)`).
Причината за това е, че това, първо, сериозно би намалило функционалността на самия контейнер (понеже би трябвало всички
типове, с които се инстанцират обектите на класа `std::vector` също да могат да се сериализират в изходен поток),
и второ, защото би довело до неявни бъгове. Ако си представим, че класът има такъв метод, и се опитаме да
създадем някакъв вектор с тип, който не може да се сериализира, то *даже не бихме получили компилационна грешка*,
както вече разбрахме в последната точка по-горе. При по-обемна програма такъв бъг невинаги би бил тривиален за откриване.

## Голяма шестица

Голямата шестица са шест метода, които би трябвало да има всеки един клас,
който използва динамична памет, константни полета или псевдоними като полета
или в някои случаи на наследяване. Съответните методи са:

- конструктор по подразбиране;

- копиращ конструктор;

- конструктор за преместване;

- копиращ оператор за присвояване;

- преместващ оператор за присвояване;

- деструктор.

Подробно за голямата четворка: https://github.com/T3Nzw/oop-kn1-group3-practicum-2024-25/blob/main/04.%20Rule%20of%20Three/additional/ro3.md

Допълнително си припомнете функциите и важните неща при всеки от тях
(отново, има ги в хранилището по ООП), понеже ще ги използваме в рамките
на целия семестър.

Други неща, които също можете да си припомните, са псевдонимите,
едносвързаните списъци и шаблонът итератор (ще ги учим отново от самото начало,
така че не е страшно и да ги пропуснете), наследяване (ще ни е полезно при дървета).

Добре е да си припомните и четенето и писането във файлове, тъй като не е
изключено да се появят задачи за сериализация и десериализация (казвам го от личен опит :D).
Линк към Markdown файла с темата за файлове от курса по ООП: https://github.com/T3Nzw/oop-kn1-group3-practicum-2024-25/blob/main/01.%20Files/additional/files.md
