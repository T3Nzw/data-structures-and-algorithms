# Двойносвързан списък

Двойносвързаният списък е частен случай на свързан списък,
при който имаме двустранни връзки между елементите -
за разлика от едносвързания списък, можем да обхождаме
елементите и в двете посоки.

## Операции

- `empty` - проверка дали списък е празният такъв;
- `create` - създаване на празен списък;
- `insert(el, pos)` - вмъкване на елемент на дадена позиция в списъка;
- `remove(pos)` - премахване на елемент на дадена позиция в списъка;
- `at(pos)` - взимане на стойността на елемента на дадената позиция в списъка.

## Реализация

Подобно на едносвързания списък, се реализира чрез
структура, представяща възел в структурата,
но има допълнително поле, сочещо към предишния елемент.

```cpp
template<typename T>
struct Node {
  T data;
  Node *prev;
  Node *next;
};

```
<pre style="font-family: monospace; line-height: 1.2;">
┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐
│ 1 │───►│ 2 │───►│ 3 │───►│ 4 │───►│ 5 │
│   │◄───│   │◄───│   │◄───│   │◄───│   │
└───┘    └───┘    └───┘    └───┘    └───┘
</pre>

## Шаблонът Итератор

В контекста на едносвързаните списъци разгледахме само еднопосочен итератор -
тоест, можехме да обхождаме елементите, започвайки от началото на списъка до неговия край.
Не беше особено естествено да реализираме итератор, който да обхожда елементите в обратен ред
(започвайки от края до началото на списъка), макар че това всъщност е напълно възможно (как?).
Ако обаче използваме двойносвързан списък за решението на някаква задача, то би било
напълно естествено да имаме итератор, обхождащ елементите на списъка в обратен ред.
Обикновено обратният итератор се реализира **отделно** от итератора в прав ред (защо?).
Тогава би следвало да имаме аналогичен на правия итератор интерфейс и за обратния:

- `ReverseIterator(DLL_node<T> *)`;
- `T &operator*() const`;
- `ReverseIterator &operator++()`;
- `bool operator!=(ReverseIterator const &) const`.

Разбира се, могат да се реализират и други методи на класа, които да улеснят
работата с него, например `bool operator==(ReverseIterator const &) const`,
`ReverseIterator operator++(int)` и др.

В класа за контейнера се дефинират два допълнителни метода, които обикновено
се именуват по следните начини:

- `ReverseIterator rbegin()`;
- `ReverseIterator rend()`.

Аналогично на правия итератор, тук също би следвало да имаме и константен обратен итератор.
Обикновено в стандартната библиотека константните и неконстантните итератори се реализират
**отделно** (защо?), а не се използва шаблон на някакъв по-общ клас, който да "обединява"
двата интерфейса и да прави разлика само между това, дали връщаният тип на `operator*`
е const-qualified, или не.

- `ConstReverseIterator(DLL_node<T> *)`;
- `T const &operator*() const`;
- `ConstReverseIterator &operator++()`;
- `bool operator!=(ConstReverseIterator const &) const`;

- `ConstReverseIterator rbegin() const`;
- `ConstReverseIterator rend() const`.

# Цикличен списък

Цикличните списъци са частен случай на списъци, където самият списък
образува цикъл - тоест, посленият елемент на списъка е свързан с първия му елемент.
Цикличните списъци се делят на два основни вида - едносвързани и двойносвързани.

## Задачи

### Задача 01

Да се напише функция, която приема едносвързан списък и проверява дали в него има цикъл.

### Задача 02

Да се напишат функции за цикличен едносвързан списък (може и клас), като някоя функция:

- създава цикличен едносвързан списък по подаден вектор;
- извежда всичките елементи на списъка в някакъв изходен поток;
- добавя/премахва елемент в началото на цикличен едносвързан списък;
- добавя/премахва елемент в края на цикличен едносвързан списък;
- добавя/премахва елемент след дадена позиция в цикличен едносвързан списък;
- освобождава паметта за цикличен едносвързан списък. Да се реализират
  два варианта на функцията - итеративен и рекурсивен.

## Задача 03

Нека имаме `n` на брой играчи, подредени в кръг и номерирани от `1` до `n`. Да се напише функция,
която приема число положително естествено число `k` и връща номера на победителя, спазвайки следните правила:

- всеки `k`-ти играч бива елиминиран;
- прилагаме горното правило, докато в кръга не остане единствен играч, който ще бъде именно победителят.

*Забележка*: Тази задача е по-известна като *Josephus problem*.

## Задача 04

Да се реализира шаблон на клас `DoublyLinkedList`, който поддържа основните операции за двойносвързани списъци.
Допълнително да се добавят прав и обратен итератор, всеки от които може да е константен или неконстантен.
Да се добавят методи за добавяне на елемент след и преди позиция в списъка, представена чрез итератор.
Да се напишат тестове за класа, демонстриращи неговата коректност.
