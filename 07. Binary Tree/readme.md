# Двоични дървета - 26.11.2025

*теория*

## Задачи

### Задача 01

Да се напише шаблон на клас `BinaryTree`, който представя двоично дърво
и поддържа следните операции:

- създаване на празно дърво;
- създаване на двоично дърво с дадена стойност в корена
  и ляво и дясно поддърво;
- проверка за празно дърво;
- добавяне на ляво/дясно поддърво.

Да се създаде абстракция за позиция в дървото чрез клас.
Да се създаде начин за движение по дървото, извличане на
елемент в даден възел и проверка за валидност на позицията.
Да се създаде метод на класа за двоично дърво, който
връща позиция към корена на дървото.

*Забележка*: Най-вероятно ще ви са необходими и други методи
за коректната работа на класа за двоично дърво.

---

#### Примерно дърво за следващите задачи:

```cpp
BinaryTree<int> tree1 = BinaryTree<int>{
    10,
    BinaryTree<int>{5,
                     BinaryTree<int>{1},
                     BinaryTree<int>{7}},
    BinaryTree<int>{20,
                     BinaryTree<int>{15},
                     BinaryTree<int>{30}}
};
```

---

#### Следващите функции да бъдат външни за класа и да използват създадената абстракция за позиция в двоично дърво.

---

### Задача 02

Да се напише функция, която приема двоично дърво и пресмята неговия диаметър.
Диаметър на дърво наричаме най-дългия път в дървото, започващ и завършващ в листо.

```cpp
diameter(tree1); // 5
```

### Задача 03

Да се дефинират следния функции за двоични дървета, които връщат
списък от стойностите във възлите при обхождането на двоичното дърво,
използвайки следните стратегии:

- ляво-корен-дясно;
- корен-ляво-дясно.

```cpp
inorder(tree1);  // 1 5 7 10 15 20 30
preorder(tree1); // 10 5 1 7 20 15 30
```

### Задача 04

Да се напише функция, която приема елемент от произволен тип `x` и двоично
дърво `t` и за всяко листо в `t` добавя ляв и десен наследник със стойност `x`.

### Задача 05

Да се напише функция, която приема едноместна функция `f` и двоично дърво `t`
с елементи от някакъв тип и връща ново дърво, което е получено от `t`
чрез прилагането на функцията `f` върху всеки от възлите му.
Функцията да **не** е метод на класа `BinaryTree`.

```cpp
map<int>([](int const &x) { return x `mod` 3; }, tree1);
```

```
+---1
    |---2
    |   |---1
    |   +---1
    +---2
        |---0
        +---0
```

### Задача 06

Да се напише функция, която приема двоично дърво и връща
вектор от вектори, представящи отделните нива на дървото.
За целта да се използва обхождане в широчина.

```cpp
levels(tree1);
// [ [10], [5,20], [1,7,15,30] ]
```

### Задача 07

Да се напише функция, която приема двоично дърво и връща
вектор от вектори, представящи път в дървото, започващ
от корена и завършващ в някакво листо.

```cpp
paths(tree1);
// [ [10,5,1], [10,5,7], [10,20,15], [10,20,30] ]
```

### Задача 08

Да се напише функция, която приема естествено число `n`
и двоично дърво `t` и връща дали числата от `0` до `n`
се срещат точно веднъж в `t`.
