# Едносвързани списъци - 31.10.2025

Списъците са хомогенна линейна структура от данни, която позволява
последователен достъп до елементите. Едносвързаните списъци са списъци,
които позволяват този достъп да се извършва *еднопосочно*.

<pre style="font-family: monospace; line-height: 1.2;">
┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐
│ 1 │──►│ 2 │──►│ 3 │──►│ 4 │──►│ 5 │
└───┘   └───┘   └───┘   └───┘   └───┘
</pre>

## Операции

- `empty` - проверка дали списък е празният такъв;
- `create` - създаване на празен списък;
- `insert(el, pos)` - вмъкване на елемент на дадена позиция в списъка;
- `remove(pos)` - премахване на елемент на дадена позиция в списъка;
- `at(pos)` - взимане на стойността на елемента на дадената позиция в списъка.

## Реализация

Едносвързаните списъци в С++ се реализират чрез "кутии",
които съдържат стойността на дадена позиция в списъка
и "връзка" към следващата такава кутия (имплементира се чрез
указател):

```c++
template<typename T>
struct Node {
  T data;
  Node *next;
};

Node<int> *l 
  = new Node<int>{1, 
      new Node<int>{2, 
        new Node<int>{3, 
          new Node<int>{4, 
           new Node<int>{5, 
             nullptr}}}}};
```

<pre style="font-family: monospace; line-height: 1.2;">
┌───┌───┐   ┌───┌───┐   ┌───┌───┐   ┌───┌───┐   ┌───┌───┐
│ 1 │  ─┼──►│ 2 │  ─┼──►│ 3 │  ─┼──►│ 4 │  ─┼──►│ 5 │  ─┼──►NULL
└───└───┘   └───└───┘   └───└───┘   └───└───┘   └───└───┘
  ▲
  │
 begin
</pre>

Необходимо е да имаме поне едно поле `Node *` в имплементацията на клас
за едносвързан списък, бележещ неговото начало, но често се реализира и втори
указател, бележещ същинския му край (защо?).

В стандартната библиотека едносвързан списък е дефиниран във
`<forward_list>` хедъра. Реализира се чрез единствен указател
към началото на списъка.

## Шаблонът Итератор

Вече сме се сблъсквали с няколко различни вида контейнери в С++ -
вектори, едносвързани списъци, а и ни предстои да вземем двусвързани
списъци следващия път. Тъй като това са структури, съдържащи множество
елементи, то бихме искали да извличаме тези елементи по някакъв начин,
който е достатъчно гъвкав, за да ни позволи както да преминем през всички тези
елементи, така и да използваме някакви операции върху тези елементи или техните
стойности. Затова бихме искали някакъв начин да можем да обхождаме всички
различни контейнери по някакъв общ начин, който не зависи от вътрешното им представяне
(напр. не искаме да зависим от това, дали контейнтерът е имплементиран чрез масив
или свързано представяне). С това се въвежда и шаблонът итератор, който ни предоставя
минимален интерфейс, чрез който да можем да обхождаме елементите на който и да е контейнер
(стига това да е цел на самия контейнер, напр. няма смисъл от обхождането на елементите на стек).

Минималният интерфейс, който трябва да поддържа всеки един итератор на някакъв контейнер,
се състои от следните методи (с `iter` ще означаваме името на произволен итератор):

- `iter begin()`;
- `iter end()`;
- `iter &operator++()`;
- `T operator*() const`;
- `bool operator!=() const`.

Понякога е удобно да се дефинират и други методи, като например
`iter operator++(int)`, `bool operator==() const` и други.

## Задачи

### Задача 01

Да се реализира клас `SinglyLinkedList`, който представя едносвързан списък
с елементи от произволен тип. Да се добави подходяща абстракция,
предоставяща начин за обхождане на всички елементи в списъка.

Допълнително да се добави параметризиран конструктор, приемащ
подходящ контейнер, така че долният пример да работи коректно.

```cpp
SinglyLinkedList<int> l({1,2,3,4,5});

for (SinglyLinkedList<int>::iterator it = l.begin(); it != l.end(); ++it) {
  std::cout << *it << std::endl;
}
```

Да се добавят подходящи методи за добавяне и премахване на елементи
от едносвързан списък на база някаква позиция в списъка,
зададена от итератор.

### Задача 02

Да се реализира функция, която обръща елементите на
едносвързан списък.

*Бонус*: Функцията да има константна сложност по памет.

### Задача 03

Да се реализира функция, която проверява дали едносвързан
списък е палиндром.

*Бонус*: Функцията да има константна сложност по памет.

## Задача 04

Да се реализира функция, която премахва всички
последователни повторения на елемент в едносвързан списък.

Пример:

```cpp
SinlyLinkedList<int> l({1,1,2,3,3,3,4,1,1});

removeConsecutive(l);  // [1, 2, 3, 4, 1]
```

## Задача 05

Да се реализира функция, която слива два сортирани
едносвързани списъка.

*Бонус*: Да се реализира алгоритъмът за сортиране чрез сливане.

## Задача 06

Да се реализира функция, която разделя едносвързан списък на две части
и добавя елементите на втората част от списъка в началото, но в обратен ред.

Пример:

```cpp
1 -> 2 -> 3 -> 4 -> 5

// ~>  5 -> 4 -> 1 -> 2 -> 3
```

## Задача 07

Да се реализира функция, която приема едносвързан списък, чиито елементи
са подредени по следния начин:

```cpp
el_1 -> el_2 -> ... -> el_n
```

Функцията да пренарежда елементите на списъка по следния начин:

```cpp
el_1 -> el_n -> el_2 -> el_n-1 -> ...
```

## Задача 08 - от контролно 1 по СДП на КН2, 2024/2025г.

Разглеждаме списък от стекове от елементи от произволен тип, в които елементите са
подредени в монотонно нарастващ ред от върха към дъното. Да се реализира
функция, която прехвърля елементите на стековете, които са на нечетни
позиции в списъка, в нов стек така, че елементите в него да са подредени в
монотонно намаляващ ред от върха към дъното. Новият стек да се запише на
първа позиция в списъка, а изпразнените стекове да се изтрият от списъка.

Пример:

Вход:

```
           4
3          2    7
2    3     0    4
1 -> 0 -> -1 -> 0
```

Изход:

```
-1
 0
 1
 2
 2         7
 3    3    4
 4 -> 0 -> 0
```
