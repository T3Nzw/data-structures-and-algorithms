# Дървета с произволен брой наследници - 26.11.2025

Представете си, че тук има някаква теория. Евентуално ще я добавя, обещавам...

## Задачи

### Задача 01

Да се напише шаблон на клас `Tree`, който поддържа следните операции:

- създаване на дърво с конкретна стойност за корена;
- извличане на стойността в корена;
- добавяне на поддърво на дадено дърво;
- проверка дали дърво е листо;
- проверка дали елемент се съдържа в дървото.

---

#### Примерни дървета за следните задачи:

```cpp
Tree<int> tree1 = Tree<int>{
  1,
  {
    Tree<int>{2,
                { Tree<int>{5} }},
    Tree<int>{3},
    Tree<int>{4,
                { Tree<int>{6} }}
  }
};

Tree<int> tree2 = Tree<int>{
  10,
  {
    Tree<int>{5,
               { Tree<int>{1,
                            { Tree<int>{0} }},
                 Tree<int>{3} }},
    Tree<int>{7,
               { Tree<int>{6},
                 Tree<int>{8,
                            { Tree<int>{-2,
                                          { Tree<int>{9} }}}}}},
    Tree<int>{20,
                { Tree<int>{15},
                  Tree<int>{30} }}
  }
};
```

---

### Задача 02

Да се напише функция, която приема дърво с произволен брой наследници
и връща броя на листата му. Листо в дърво наричаме възел, който няма
наследници.

```cpp
tree1.leaves(); // 3
tree2.leaves(); // 6
```

### Задача 03

Да се напише функция, която приема естествено число `n` и дърво с
произволен брой наследници и връща вектор/списък от възлите
на дървото на ниво `n`. Приемаме, че коренът на дървото се
намира на ниво 0.

```cpp
tree1.level(0); // [1]
tree2.level(2); // [5,6]
```

### Задача 04 - от контролно по СДП-практикум, 2024/2025г.

Да се напише функция, която приема две дървета с произволен брой наследници
и връща дали първото дърво е поддърво на второто. Казваме, че дървото `t1`
е поддърво на `t2`, ако в `t2` съществува поддърво `t3`, чиято стойност в корена
е равна на стойността в корена на `t1` и `t1` може да се получи от `t3` чрез премахване
на някакви елементи. Позволено е пренареждане на елементите в дадено братство.
Не може даден възел в дървото да има два преки наследника с една и съща стойност.

```cpp
tree1.isSubtreeOf(tree2); // false
```

```cpp
Tree<int> tree3 = Tree<int>{
  1,
  {
    Tree<int>{2},
    Tree<int>{4},
    Tree<int>{3},
  }
};

tree3.isSubtreeOf(tree1); // true
```

### Задача 05

Да се напише функция, която приема дърво с произволен брой наследници
и връща максималната сума от възлите в дървото, в която не участват
съседни възли. Два възела наричаме съседни, ако единият е дете на другия.

```cpp
maxSumOfNonAdjacent(tree1); // 14
maxSumOfNonAdjacent(tree2); // 82
```
