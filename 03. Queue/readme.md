# Опашка

Опашката е структура от данни, базирана на принципа FIFO (First In First Out).
За разлика от стековете при опашките елементите се натрупват в края
и имаме достъп само до първия сложен елемент в опашката.

## Операции

Опашката е АТД, който поддържа следните операции:

- `empty` - проверка дали опашка е празната такава;
- `enqueue` (`push`) - добавяне на елемент на края на опашката;
- `dequeue` (`pop`) - премахване на елемента в началото на опашката;
- `front` (`peek`) - взимане на стойността на първия елемент в опашката.

## Реализация

Подобно на стековете, опашките се реализират по три основни начина:
чрез статичен масив, чрез динамичен масив и чрез свързано представяне.

## Задачи

### Задача 01

Да се имплементира клас `Queue`, който използва свързано представяне.
Да се дефинират по-горните операции така, че всяка от тях да е с
константна сложност по време.

Допълнително да се дефинира метод, намиращ големината на опашката.

Да се напишат тестове, демонстриращи коректност на имплементацията.

## Задача 02

Да се напише функция, която по подадено естествено число `n` генерира
двоичните записи на числата от `1` до `n`.

Пример:

```c++
// n == 7
[1, 10, 11, 100, 101, 110, 111]
```

## Задача 03

Да се напише функция, която обръща елементите на опашка.
За колко възможни начина на имплементация се сещате?

Пример:

```c++
[7,4,5,1,9]  ~>  [9,1,5,4,7]
```

## Задача 04

Да се напише функция, която приема низ и връща
индекса на първия уникален елемент в него.
Алгоритъмът да има *линейна* сложност по време.

Пример:

```c++
"abcd abc"  ~>  3
"abba"      ~> -1
```

## Задача 05

Да се имплементира опашка, използвайки два стека.

## Задача 06

Дадена е шахматна дъска с размери `n x n`. Да се напише функция,
която приема начална позиция и крайна позиция на кон
и намира минималния брой стъпки, за които конят може да достигне
до крайната позиция от началната. Ако такъв път не съществува,
да се върне `-1`.
